namespace BGE

  class GameEntity
    '-----Constants-----

    ' Constant - name of this Entity
    name as string
    ' Constant - Unique Id
    id as string

    private game as object

    ' -----Variables-----

    ' Is this GameEntity enabled
    enabled as boolean = true
    ' Does this entity persist across room changes?
    persistent as boolean = false
    ' When the game is paused, does this entity pause too?
    pauseable as boolean = true
    ' Depth is used when handling draw order in the game loop - lower depth is drawn first
    depth as integer = 0
    ' x position of where this entity is in game world
    x as float = 0.0
    ' y position of where this entity is in game world
    y as float = 0.0
    ' Speed in x/horizontal direction
    xspeed as float = 0.0
    ' Speed in y/vertical direction
    yspeed as float = 0.0

    ' The colliders for this entity by name
    colliders as object = {}
    ' The array of images to draw for this entity
    images as object = []
    ' Associative array of images by name
    imagesByName as object = {}


    ' Creates a new GameEntity
    '
    ' @param {object} game - The game engine that this entity is going to be assigned to
    ' @param {object} [args={}] Any extra properties to be added to this entity
    ' @return
    function new(game as object, args = {} as object)
      m.game = game
      m.id = m.game.getGameEntityId()
      m.append(args)
    end function


    ' Is this still a valid entity?
    '
    ' @return {boolean} - true if still valid
    function isValid() as boolean
      return m.id <> invalid
    end function


    ' Method to be called when this entity is added to a Game
    '
    ' @param {object} args
    function onCreate(args as object) as void
    end function


    ' Method for handling any updates based on time since previous frame
    '
    ' @param {float} deltaTime - milliseconds since last frame
    function onUpdate(deltaTime as float) as void
    end function



    ' Method for processing all collisions
    '
    ' @param {object} collider - the collider of this entity that collided
    ' @param {object} other_collider - the collider of the other entity in the collision
    ' @param {object} other_entity - the entity that owns the other collider
    function onCollision(collider as object, other_collider as object, other_entity as object) as void
    end function


    ' Method called each frame before drawing any images of this entity
    '
    ' @param {object} canvas - the canvas images will be drawn to
    function onDrawBegin(canvas as object) as void
    end function


    ' Method called each frame after drawing all images of this entity
    '
    ' @param {object} canvas - the canvas images were drawn to
    function onDrawEnd(canvas as object) as void
    end function


    ' Method to process input per frame
    '
    ' @param {object} input - GameInput object for the last frame
    function onInput(input as object) as void
    end function


    ' Method to process an ECP keyboard event
    ' https://developer.roku.com/en-ca/docs/developer-program/debugging/external-control-api.md
    '
    ' @param {integer} char
    function onECPKeyboard(char as integer) as void
    end function


    ' Method to process an External Control Protocol event
    ' https://developer.roku.com/en-ca/docs/references/brightscript/events/roinputevent.md
    '
    ' @param {object} data
    function onECPInput(data as object) as void
    end function


    ' Method to handle audio events
    '
    ' @param {object} msg - roAudioPlayerEvent
    function onAudioEvent(msg as object) as void
    end function

    function onPause() as void
    end function

    function onResume(pause_time) as void
    end function

    function onUrlEvent(msg) as void
    end function

    function onGameEvent(eventName as string, data as object) as void
    end function

    function onChangeRoom(new_room as object) as void
    end function

    function onDestroy() as void
    end function


    function addCircleCollider(collider_name as string, radius as float, offset_x = 0 as float, offset_y = 0 as float, enabled = true as boolean) as void
      collider = new CircleCollider(collider_name, {
        enabled: enabled,
        radius: radius,
        offset_x: offset_x,
        offset_y: offset_y
      })
      collider.setupCompositor(m.game, m.name, m.id, m.x, m.y)
      if m.colliders[collider_name] = invalid
        m.colliders[collider_name] = collider
      else
        print "addColliderCircle() - Collider Name Already Exists: " + collider_name
      end if
    end function

    function addRectangleCollider(collider_name as string, offset_x as float, offset_y as float, width as float, height as float, enabled = true as boolean) as void
      collider = new RectangleCollider(collider_name, {
        enabled: enabled,
        offset_x: offset_x,
        offset_y: offset_y,
        width: width,
        height: height
      })
      collider.setupCompositor(m.game, m.name, m.id, m.x, m.y)
      if m.colliders[collider_name] = invalid
        m.colliders[collider_name] = collider
      else
        print "addColliderRectangle() - Collider Name Already Exists: " + collider_name
      end if
    end function

    function addCollider(collider as object) as void
      collider_name = collider.name
      collider.setupCompositor(m.game, m.name, m.id, m.x, m.y)
      if m.colliders[collider_name] = invalid
        m.colliders[collider_name] = collider
      else
        print "addCollider() - Collider Name Already Exists: " + collider_name
      end if
    end function

    function getCollider(collider_name as string) as object
      if m.colliders.DoesExist(collider_name)
        return m.colliders[collider_name]
      else
        return invalid
      end if
    end function

    function removeCollider(collider_name as string) as void
      if m.colliders[collider_name] <> invalid
        if type(m.colliders[collider_name].compositor_object) = "roSprite"
          m.colliders[collider_name].compositor_object.Remove()
        end if
        m.colliders.Delete(collider_name)
      end if
    end function

    function clearAllColliders() as void
      if invalid <> m.colliders
        for each collider_key in m.colliders
          m.removeCollider(collider_key)
        end for
      end if
    end function

    function addImage(image_name as string, region as object, args = {} as object, insert_position = -1 as integer) as object
      image_object = new Image(m, region, m.game.getCanvas(), args) 'm as first arg
      return m.addImageObject(image_name, image_object, insert_position)
    end function

    function addAnimatedImage(image_name as string, regions as object, args = {} as object, insert_position = -1 as integer) as object
      image_object = new AnimatedImage(m, regions, m.game.getCanvas(), args)
      return m.addImageObject(image_name, image_object, insert_position)
    end function

    function addImageObject(image_name as string, image_object as object, insert_position = invalid as integer) as object
      image_object.name = image_name

      if m.getImage(image_object.name) <> invalid
        print "addImageObject() - An image named - " + image_object.name + " - already exists"
        return invalid
      end if

      m.imagesByName[image_object.name] = image_object
      if insert_position = -1
        m.images.Push(image_object)
      else if insert_position = 0
        m.images.Unshift(image_object)
      else if insert_position < m.images.Count()
        BGE.ArrayInsert(m.images, insert_position, image_object)
      else
        m.images.Push(image_object)
      end if

      return image_object
    end function

    function getImage(image_name) as object
      return m.imagesByName[image_name]
    end function

    function removeImage(image_name as string) as void
      m.imagesByName.Delete(image_name)
      if m.images.Count() > 0
        for i = 0 to m.images.Count() - 1
          if m.images[i].name = image_name
            m.images.Delete(i)
            exit for
          end if
        end for
      end if
    end function

    function getStaticVariable(static_variable_name as string) as dynamic
      if m.game.Statics.DoesExist(m.name) and m.game.Statics[m.name].DoesExist(static_variable_name)
        return m.game.Statics[m.name][static_variable_name]
      else
        return invalid
      end if
    end function

    function setStaticVariable(static_variable_name as string, static_variable_value as dynamic) as void
      if m.game.Statics.DoesExist(m.name)
        m.game.Statics[m.name][static_variable_name] = static_variable_value
      end if
    end function

    function addInterface(interface_name as string) as void
      interfaceObj = {owner: m}
      m.game.Interfaces[interface_name](interfaceObj)
      m[interface_name] = interfaceObj
    end function

    function hasInterface(interface_name as string) as boolean
      return (m.DoesExist(interface_name) and m[interface_name] <> invalid)
    end function

  end class
end namespace